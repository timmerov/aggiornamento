/*
Copyright (C) 2012-2016 tim cotter. All rights reserved.
*/

/**
lock free queue example.

hey! what gives? why isn't there any code here?

lock free queues are mythical beasts.
like unicorns.
don't use them.
no really, they don't work.
use the low contention fifo from that example instead.

but but but... why????!!!!

okay.
first a question:
how does the consumer know when the producer has put
something in the lock free queue?
either it doesn't.
and it polls.
or the producer signals the consumer.
hey, guess what!
semaphores use locks.
condition variables use locks.
so right off the bat...
either your lock free queue isn't actually lock free.
or the consumer has to poll it.
which is terribly inefficient.

but but but...
okay let's stick our heads in the sand just to find
the pitfalls involved with making a lock free queue.
first, you must look at the code generated by the
compiler on every target machine.
optimizing compilers tend to rewrite your beautiful code.
which can have unexpected consequences.
like your beautiful code no longer works.
okay good.
no go through every instruction and try to figure
out what happens if there's a context switch right there.
does your code still work?

oh wait, nevermind.
modern cpus execute instructions out of order.
okay so stick in some compile barriers.

oh wait, nevermind. yes, again.
modern cpus flush their caches out of order.
so just because the compiler generated code in the
desired order, and you've forced the hardware to
execute the instructions in that order...
the memory manager could still write the results
in the wrong order.

convinced yet?
i've worked with very smart people who tried to make
a lock free queue.
they work great in the lab.
but run them 24/7 on a few thousand machines and fail.
for 10 YEARS they tried and failed to make their lock
free queue work out in the wild.
if you're going to invest that much effort trying to
capture the mythical lock free queue...
you'd do much better to use the low contention fifo
from example 04.
and optimize your code somewhere else.

no really...
the low contention fifo suffers from many of the above
pitfalls.
go read the documentation in fifo.cc.
then decide if you really want to go unicorn hunting.
**/

#include <aggiornamento/aggiornamento.h>
#include <aggiornamento/log.h>


int main(
    int argc, char *argv[]
) throw() {
    (void) argc;
    (void) argv;

    agm::log::init(AGM_TARGET_NAME ".log");

    LOG("Hello, World!");
    LOG("Goodbye, World!");

    return 0;
}
